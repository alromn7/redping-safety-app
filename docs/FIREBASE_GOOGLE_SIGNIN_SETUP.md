# Firebase Google Sign‑In Setup (Android + Web) and Production Firestore Rules

Goal: Configure proper Google authentication for the RedPing mobile app (Flutter) and website (Next.js) so Firestore rules can be tightened without future rework.

Contents
- 1) Prerequisites
- 2) Firebase Authentication: Enable Google
- 3) Android: Add SHA fingerprints and update google-services.json
- 4) Website (Next.js): Sign in to Firebase (Google)
- 5) Firestore Rules: Testing vs Production
- 6) Vercel deployment (env + tips)
- 7) Troubleshooting
- 8) Quick checklist

1) Prerequisites
- A single Firebase project for both mobile and web (projectId: redping-a2e37 or your chosen prod)
- Firebase Console access
- Android keystore(s) available (debug and release)
- For Next.js site: ability to deploy via Vercel

2) Firebase Authentication: Enable Google
- Firebase Console > Authentication > Sign-in method
  - Enable the Google provider
  - Select a Project support email
  - Save
- Authorized domains (on the same screen):
  - Add your Vercel Production domain
  - Add your Vercel Preview domain(s)
  - Add localhost (for local development)

Optional: Anonymous sign-in (for public read-only dashboards)
- Enable Anonymous if you want unauthenticated users to see limited data.
- For strict environments, disable after testing.

3) Android: Add SHA fingerprints and update google-services.json
A) Get debug SHA-1/SHA-256
- From project root:

```powershell
# Windows / PowerShell
cd android
./gradlew signingReport
```

- Find variant debug and copy:
  - SHA-1
  - SHA-256

B) Get release SHA-1/SHA-256 (your release keystore)

```powershell
keytool -list -v -keystore "C:\\path\\to\\release.keystore" -alias your_alias_name
```

- Enter the keystore password and copy SHA-1 and SHA-256.
- If you use Play App Signing: also add SHA-1/256 from Play Console > App integrity > App signing certificates.

C) Add fingerprints to Firebase and refresh config
- Firebase Console > Project Settings > Your apps > Android app (your packageId)
  - Add fingerprint: paste SHA-1, SHA-256
  - Save
- Download the updated google-services.json
  - Place it at: android/app/google-services.json (replace existing)
- Rebuild the app when testing Google Sign-In.

D) Flutter app code (when adding Google sign-in)
- Add the package to pubspec.yaml:

```yaml
# pubspec.yaml
# ...
dependencies:
  google_sign_in: ^6.2.1
  firebase_auth: ^5.3.3
```

- Sign in and link to FirebaseAuth:

```dart lib/example_google_signin.dart
import 'package:google_sign_in/google_sign_in.dart';
import 'package:firebase_auth/firebase_auth.dart';

Future<UserCredential> signInWithGoogle() async {
  final googleUser = await GoogleSignIn().signIn();
  if (googleUser == null) throw Exception('Google sign-in aborted');
  final googleAuth = await googleUser.authentication;
  final credential = GoogleAuthProvider.credential(
    accessToken: googleAuth.accessToken,
    idToken: googleAuth.idToken,
  );
  return FirebaseAuth.instance.signInWithCredential(credential);
}
```

- Note: requestIdToken defaults to your default_web_client_id from strings (generated by google-services.json). Adding SHA fingerprints ensures a valid OAuth client exists.

4) Website (Next.js): Sign in to Firebase (Google)
Recommended: Use Firebase Web sign-in directly for dashboard reads/writes.
- Ensure your client initializes Firebase with NEXT_PUBLIC_FIREBASE_* env vars.
- Add a small UI flow to sign in with Google via FirebaseAuth on the client.

Example button component:

```tsx src/components/SignInWithGoogleButton.tsx
'use client'
import { getAuth, GoogleAuthProvider, signInWithPopup } from 'firebase/auth'
import { getClientDb } from '@/lib/firebase/client' // ensures app init

export default function SignInWithGoogleButton() {
  const onClick = async () => {
    const auth = getAuth()
    await signInWithPopup(auth, new GoogleAuthProvider())
    console.log('Signed in as:', auth.currentUser?.uid)
  }
  return <button onClick={onClick}>Sign in with Google</button>
}
```

- Place this in your dashboard header or a client page.
- After sign-in, Firestore rules see request.auth and listeners will work without relaxed rules.

Alternative (advanced): NextAuth Google + Firebase bridging
- If you must use NextAuth, safelist the external Google Client ID in Firebase > Auth > Google > Safelist client IDs.
- Exchange the NextAuth Google ID token into Firebase via:
  - signInWithCredential(GoogleAuthProvider.credential(idToken: ...))
- Use this only if you require NextAuth-specific session flows.

5) Firestore Rules: Testing vs Production
Testing (simple, signed users):

```plaintext firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() { return request.auth != null; }

    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if request.auth.uid == userId; // owner
    }

    // Allow signed users to read/write SOS and Help during QA
    match /sos_sessions/{id} {
      allow read, create, update: if isAuthenticated();
      allow delete: if false;
    }
    match /help_requests/{id} {
      allow read, create, update: if isAuthenticated();
      allow delete: if false;
    }

    // Other collections as needed for testing
    match /sar_messages/{id} {
      allow read, create, update: if isAuthenticated();
      allow delete: if false;
    }

    match /{document=**} { allow read, write: if false; }
  }
}
```

Production (owner + roles example):
- Example assumes you store roles under users/<uid>.roles and restrict SAR-only reads accordingly.

```plaintext firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() { return request.auth != null; }
    function isOwner(userId) { return isAuthenticated() && request.auth.uid == userId; }
    function hasRole(role) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny([role, 'ADMIN']);
    }
    function isSAR() { return hasRole('SAR_MEMBER') || hasRole('SAR_LEADER'); }

    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId) || hasRole('ADMIN');
    }

    match /sos_sessions/{id} {
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || isSAR());
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isSAR()
      );
      allow delete: if false;
    }

    match /help_requests/{id} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isSAR()
      );
      allow delete: if false;
    }

    match /sar_messages/{id} {
      allow read: if isSAR();
      allow create, update: if isSAR();
      allow delete: if false;
    }

    match /{document=**} { allow read, write: if false; }
  }
}
```

6) Vercel deployment (env + tips)
A) Environment variables (Project Settings > Environment Variables)
- NEXT_PUBLIC_FIREBASE_API_KEY
- NEXT_PUBLIC_FIREBASE_APP_ID
- NEXT_PUBLIC_FIREBASE_PROJECT_ID = redping-a2e37
- NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
- NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN = redping-a2e37.firebaseapp.com
- NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET = redping-a2e37.appspot.com
- Optional: NEXT_PUBLIC_DISABLE_WEBSOCKETS=1 (if you don’t have a Socket.IO server yet)

B) Redeploy
- vercel --prod (or push to main)
- Hard refresh the browser to load new JS

7) Troubleshooting
- Permission denied (web):
  - Ensure Firebase web client signs in (Google or anonymous). Check console log for uid.
  - Confirm Authorized domains includes your site.
  - Confirm rules are published to the same project the site uses.

- Permission denied (app):
  - Confirm FirebaseAuth signed in (anonymous or Google). Check logs.
  - Ensure sos/help writes include userId == FirebaseAuth.uid when rules enforce ownership.

- Android Google Sign-In fails:
  - Add SHA-1/SHA-256 fingerprints and download updated google-services.json.
  - If Play App Signing: also add Play signing certs.

- WebSocket 400/connection failed:
  - No Socket.IO server at /api/socket.io; set NEXT_PUBLIC_DISABLE_WEBSOCKETS=1 or implement a handler.

- Project mismatch:
  - Print/log projectId in app and website to confirm both target the same Firebase project.

8) Quick checklist
- Google Auth enabled (Firebase)
- Authorized domains set (Firebase)
- Android SHA-1/SHA-256 added (Firebase), updated google-services.json in android/app
- Website signs in to Firebase (Google) – simple button or automatic popup
- Firestore rules published (testing or production as desired)
- Vercel env vars correct and deployed
- Mobile writes visible in Firestore; website reads without permission errors

Done. This setup allows proper Google authentication on both app and web, enabling you to lock Firestore rules to owner/role checks without code changes later.